---
title: "freesurfer: Connecting the Freesurfer Software with R"
author:
  - name: John Muschelli
    affiliation: Johns Hopkins Bloomberg School of Public Health
    address:
    - Department of Biostatistics
    - 615 N Wolfe St, Baltimore, MD, 21205
    email: jmuschel@jhsph.edu
  - name: Elizabeth M. Sweeney
    affiliation: Rice University
    address:
    - Department of Statistics 
    - 6100 Main St, Duncan Hall, Houston, TX, 77005
    email: ems15@rice.edu 
  - name: Ciprian M. Crainiceanu
    affiliation: Johns Hopkins Bloomberg School of Public Health
    address:
    - Department of Biostatistics
    - 615 N Wolfe St, Baltimore, MD, 21205
    email: ccraini1@jhu.edu
abstract: >
  We present the package \CRANpkg{freesurfer}, a set of R functions that interface with Freesurfer, a commonly-used open-source software package for processing and analyzing structural neuroimaging data, specifically T1-weighted images.  The \pkg{freesurfer} package performs operations on \code{nifti} image objects in R using command-line functions from Freesurfer, and returns R objects back to the user.  \pkg{freesurfer} allows users to process neuroanatomical images and provides functionality to convert and read the output of the Freesurfer pipelines more easily. 
preamble: >
  % Any extra latex you need in the preamble
output: rticles::rjournal_article
---

```{r setup, echo = FALSE, message = FALSE}
library(knitr)
opts_chunk$set(
  eval = FALSE,
  echo = TRUE, 
  prompt = FALSE, 
  message = FALSE, 
  warning = FALSE, 
  comment = "", results = 'hide',
  fig.width = 6,
  fig.height = 3,
  cache = TRUE)
library(freesurfer)
library(pander)
library(neurobase)
```

```{r, echo = FALSE}
# surf_convert
 if (have_fs()) {
   fname = file.path(bert_dir, "surf", "lh.thickness")
    out = surf_convert(fname)
 }
 if (have_fs()) {
    bert_dir = file.path(fs_subj_dir(), "bert", "surf")
    file = file.path(bert_dir, "lh.thickness")
    out = freesurfer_read_curv(file)
 } 

 if (have_fs()) {
    fname = file.path(fs_subj_dir(), "bert", "surf", "lh.inflated")
    out = freesurfer_read_surf(fname)
 }


#' if (have_fs()) {
#'  freesurferdir()
#'  freesurfer_dir()
#'  fs_dir()
#' }

# aparcstats2table
#' if (have_fs()) {
#'    outfile = aparcstats2table(subjects = "bert",
#'                     hemi = "lh",
#'                     meas = "thickness")
#'    df = read_fs_table(outfile)
#'    seg_outfile = asegstats2table(subjects = "bert", meas = "mean")
#'    df_seg = read_fs_table(seg_outfile)
#' }
#' \dontrun{
#' ### using the pipe
#' df_seg = asegstats2table(subjects = "bert", meas = "mean") %>% 
#'             read_fs_table
#' }
#' if (have_fs()) {
#'    outfile = asegstats2table(subjects = "bert",
#'                     meas = "mean")
#' }
```

```{r braingraph, echo = FALSE}
#' if (have_fs()) {
#'    df = aparcs_to_bg(subjects = "bert", measure = "thickness")
#'    print(head(df))
#' }
```

```{r nifti, echo = FALSE}
#' if (have_fs()){
#'    img = oro.nifti::nifti(array(rnorm(5*5*5), dim = c(5,5,5)))  
#'    mri_info(img)
#' }


# \dontrun{
#' if (have_fs()){
#'     mri_watershed("/path/to/T1.nii.gz")
#' } 
#' }  

#' @examples \dontrun{
#' if (have_fs()){
#'     mri_normalize("/path/to/T1.nii.gz")
#' } 
#' }

  #' if (have_fs()) {
#'    img = oro.nifti::nifti(array(rnorm(5*5*5), dim = c(5,5,5))) 
#'    res = mri_convert(img, outfile = tempfile(fileext = ".mgz"))
#' } 

  #' if (have_fs()) {
#'    img = oro.nifti::nifti(array(rnorm(5*5*5), dim = c(5,5,5)))  
#'    mnc = nii2mnc(img)
#'    img_file = mnc2nii(mnc)
#' }
#' if (have_fs()) {
#'    img = oro.nifti::nifti(array(rnorm(5*5*5), dim = c(5,5,5)))  
#'    mnc = nii2mnc(img)
#'    img_file = mnc2nii(mnc)
#' }

  #' if (have_fs()) {
#'    img = oro.nifti::nifti(array(rnorm(5*5*5), dim = c(5,5,5)))  
#'    mask = img > 1
#'    res = mri_mask(img, mask)
#' }
#' @examples \dontrun{
#' if (have_fs()){
#'     nu_correct("/path/to/T1.nii.gz")
#' } 
#' } 
```


# Introduction

\label{sec:intro}

Freesurfer is a commonly-used software for processing and analyzing anatomical neuroimaging data \citep{fischl2012freesurfer}, developed by the Laboratory for Computational Neuroimaging at the Athinoula A. Martinos Center for Biomedical Imaging.  This software provides open-source, command-line tools for image processing tasks such as brain extraction/skull-stripping \citep{segonne2004hybrid}, bias-field correction \citep{sled_nonparametric_1998}, segmentation of structures within the brain \citep{fischl2002whole,fischl2004sequence}, and image registration \citep{fischl1999high,reuter2010highly}.  In additio to these functions, Freesurfer has functions that perform complete pipelines for the user.   

We have previously published a similar adaptation of the FSL imaging software \citep{jenkinson_fsl_2012} to R, called \CRANpkg{fslr} \citep{muschelli2015fslr}.  Again, we note that there exist a number of R packages for reading and manipulating image data, including \CRANpkg{AnalyzeFMRI} \citep{bordier_temporal_2011}, \CRANpkg{RNiftyReg} \citep{modat_rniftyreg:_2013}, and \CRANpkg{fmri} \citep{tabelow_statistical_2011} (see the Medical Imaging CRAN task view \url{http://cran.r-project.org/web/views/MedicalImaging.html} for more information).  Although these packages are useful for performing image analysis, much of the functionality of image processing that Freesurfer provides are not currently implemented in R, including surface-based registration.  The \pkg{ANTsR} package (\url{https://github.com/stnava/ANTsR}) is a currently unpublished R package that interfaces with the ANTs (advanced normalization tools) software suite \citep{avants_reproducible_2011}, where a lot of additional functionality has been implemented, but this package has not been released onto CRAN.  Moreover, having multiple options for image processing through R allows for users to compare methods and the flexibility of using multiple packages to achieve a working data processing pipeline. 

In particular, we provide an interface to users to the state-of-the-art anatomical processing implemented in Freesurfer, as well as a suite of tools that simplify analyzing the output of Freesurfer.  The \pkg{freesurfer} allow R users to implement complete anatomical imaging analyses without necessarily learning Freesurfer-specific syntax.  

## Imaging formats in \pkg{freesurfer} and R

The \CRANpkg{freesurfer} package relies on the \CRANpkg{oro.nifti} \citep{whitcher_working_2011} package implementation of images (referred to as \code{nifti} objects) that are in the Neuroimaging Informatics Technology Initiative (NIfTI) format, as well as other common image formats such as ANALYZE.  Some Freesurfer functions require other formats, such as MINC (\url{http://www.bic.mni.mcgill.ca/ServicesSoftware/MINC}).  The Freesurfer installation provides functions to convert from MINC to NIfTI formats and there are implemented in functions such as \code{nii2mnc} and \code{mnc2nii} in R.  Moreover, the \code{mri\_convert} Freesurfer function has been interfaced in the \code{freesurfer} package (same function name), which allows for a more general conversion tool of imaging types for R users than currently implemented in native R.  Thus, many formats can be converted to NIfTI and then read into R using the \code{readNIfTI} function from \pkg{oro.nifti}.

## Reconstruction pipeline in Freesurfer

The Freesurfer pipeline and analysis workflow for neuroanatomical images is based on a structural magnetic resonance image (MRI) of the brain.  The specific type of image commonly used in this software is a T1-weighted image, a specific MRI sequence commonly taken.
The full pipeline is implemented in the Freesurfer \code{recon-all} function, where the "recon" stands for reconstruction (\url{https://surfer.nmr.mgh.harvard.edu/fswiki/recon-all}).  The `recon-all` function is the main workhorse of Freesurfer and is commonly the one command used for an entire processing pipeline.  Using the \code{-all} flag in the the \code{recon-all} function performs over 30 different steps and takes 20-40 hours to fully process a subject when performing all the steps ([https://surfer.nmr.mgh.harvard.edu/fswiki/recon-all](https://surfer.nmr.mgh.harvard.edu/fswiki/recon-all)).  This process is the common way of fully processing an T1-weighted image in Freesurfer, and is implemented in the `recon_all` \pkg{freesurfer} function.

If there are problems with the result of this processing, there are multiple steps where users can edit certain parts of the processing, such as brain extraction, where non-brain tissues are removed from the image.  The remainder of the pipeline can be run after these steps are corrected.  The full pipeline is broken down into 3 separate sets of steps, referred to as \code{autorecon1}, \code{autorecon2}, and \code{autorecon3}, which correspond to the same-named flags in \code{recon-all} used to initiate these steps.  We have written wrapper functions \code{autorecon1}, \code{autorecon2}, and \code{autorecon3}, respectively, so users can run pieces of the pipeline if desired or restart a failed process after correction to the data.

## R function setup

To use \pkg{freesurfer}, a working installation of Freesurfer is required.  The following code was run using Freesurfer version "`r fs_version()`".  The Freesurfer version can be accessed using the \code{fs\_version} function. \pkg{freesurfer} must also have the path of Freesurfer specified.  If using R from a shell environment, and the \code{FREESURFER\_HOME} environment variable is set (which is done when installing Freesurfer), \pkg{freesurfer} will use this as the path to Freesurfer.  If using R through a graphical user interface (GUI) such as RStudio (RStudio, Boston, MA), environmental variables and paths are not explicitly exported.  Therefore, \code{FREESURFER\_HOME} is not set, \pkg{freesurfer} will try the default directories of Mac OSX and Linux.  If the user did not perform an standard installation of Freesurfer, the path to Freesurfer can be specified using \code{options(freesurfer.path="/path/to/freesurfer")}.  The \code{have\_fs} function tests whether a user has a Freesurfer installation, returning a logical, which is useful for \code{if} statements and examples for packages.  If this is true, the \code{fs\_dir} function will return the directory of the Freesurfer installation.  

### Structure of Freesurfer analyses

During the installation of Freesurfer, additional environment variables are set in addition to \code{FREESURFER\_HOME}.  One of these variables is \code{SUBJECTS\_DIR}, which refers to a directory of the output of analysis from all subjects.  The \code{fs\_subj\_dir} function will return the path to the Freesurfer subjects directory if it is set.    This default setup of a subjects directory in Freesurfer allows users to simply specify a subject identifier to analyze, rather than a specific path or multiple intermediate files.  

This setup may not be desirable if the user prefers to structure his/her data differently.  For example, if data from multiple studies are present, these may be organized into different folders in different locations.  Some functions in Freesurfer rely on the \code{SUBJECTS\_DIR} variable to run.  For example, the \code{asegstats2table} function takes the **a**natomical **seg**mentation **stat**istics and convert it to a table.  The default argument for \code{asegstats2table} is to pass in a subject name rather than a file.  

To provide flexibility to the user, \pkg{freesurfer} allows most functions to specify a file or different directory rather than the subject.  A function may temporarily set \code{SUBJECTS\_DIR} to a temporary directory with the data, excecute the command, then reset the \code{SUBJECTS\_DIR} variable, or allow for a different subjects directory.  This provides a more flexible workflow.  For example, the \pkg{freesurfer} \code{asegstats2table} function allows the R user to specify a different subject directory to read in the file, while not overriding the default set by \code{SUBJECTS\_DIR}.  This functionality allows users to have separate folders with subjects and read in the data by simply switching the \code{subj\_dir} argument in the R function. 





<!-- \section{\pkg{fslr} workflow} -->
<!-- The general workflow for most \pkg{fslr} functions that interface with FSL is as follows: -->
<!-- \begin{enumerate} -->
<!-- \item Filename or \code{nifti} object is passed to \pkg{fslr} function. -->
<!-- \item FSL command is created within \pkg{fslr} function and executed using the \code{system} command. -->
<!-- \item Output is written to disk and/or read into R and returned from the function. -->
<!-- \end{enumerate} -->

Some Freesurfer functions require an image as an input.  For those functions, the R \pkg{freesurfer} functions that call those Freesurfer functions will take in a file name or a \code{nifti} object. The R code will convert the \code{nifti} to the corresponding input required for Freesurfer.  From the user's perspective, the input/output process is all within R, with one object format (\code{nifti}).  The advantage of this approach is that the user can read in an image, do manipulations of the \code{nifti} object using standard syntax for arrays, and pass this object into the \pkg{freesurfer} R function. Thus, users can use R functionality to manipulate objects while seamlessly passing these object to Freesurfer through \pkg{freesurfer}. 


# Example analyses and use of functions

In the default subjects directory in the Freesurfer installation, there is a subject named "bert", where \code{recon-all} was run.   A user can see the result of this output in the "bert" directory:

```{r, eval = TRUE, warning=FALSE, results='markup'}
list.files(path  = file.path(fs_subj_dir(), "bert"))
```

We will explore the results in "mri", which contain imaging data, "stats", which containing statistics based on structures of the brain, and "surf", which contain the surface and curvature output from the Freesurfer processing.  

## Reconstruction

For the `recon_all` function, users must specify the input file (a T1-weighted image), the output directory, and the subject identifier.  This function will take 20-40 hours to fully process the input file.  

```{r eval = FALSE}
recon_all(infile, outdir, subjid)
```



### Reading in anatomical statistics

The "aseg.stats" in the "stats" folder of subject bert corresponds to measures and statistics from the anatomical segmentation.  The \code{read\_aseg\_stats} function reads this corresponding file and creates a list of 2 different \code{data.frame}s:

```{r read_aseg_stats, eval = TRUE, results='markup'}
file = file.path(fs_subj_dir(), "bert", "stats", "aseg.stats")
out = read_aseg_stats(file)
names(out)
```

The \code{measures} element corresponds to global measurements of the brain (e.g. volume of the brain) as well as measures of gross anatomical structures (e.g. gray matter).  


```{r read_aseg_stats_meas, echo = TRUE, eval = TRUE, results='markup'}
head(out$measures[, c("meaning", "value", "units")], n = 3)
```

In some imaging analyses, comparing at these large measures of brain volume over time or across groups are of interest.  

The \code{structures} element corresponds to a set of measures and statistics for a set of fixed anatomical structures.

```{r read_aseg_stats_struct, echo = TRUE, eval = TRUE, results='markup'}
head(out$structures, n = 3)
```

Similarly with global measures, these structure-specific measures can be used in analysis.  Moreover, a large deviation in volume for a specific subject may indicate atrophy of a structure or an indication of a segmentation error.  


### MRI conversion: the \code{mri\_convert} function

The typical output format from Freesurfer is MGH/MGZ format, which is explained here: \url{https://surfer.nmr.mgh.harvard.edu/fswiki/FsTutorial/MghFormat}.  As NIfTI formats are one of the most common formats and has been the common format for analysis in the \pkg{oro.nifti} and \pkg{neurobase} packages, it is useful to convert these files to a NIfTI format to read into R.   The \code{mri\_convert} Freesurfer function will be used for that.  Here we will use the T1-weighted image from the "bert" subject and convert it to NIfTI, and read it into R:

```{r mri_convert, echo = TRUE, eval = TRUE}
library(freesurfer)
bert_dir = file.path(fs_subj_dir(), "bert") # subject directory
t1_mgz = file.path(bert_dir, "mri", "T1.mgz") # mgz file
t1_nii_fname = tempfile(fileext = ".nii.gz") # temporary NIfTI file
freesurfer::mri_convert(t1_mgz, t1_nii_fname) # conversion
img = neurobase::readnii(t1_nii_fname) # read in outputs
```

As this is a commonly-used function, we have wrapped these two steps into the `readmgz` and `readmgh` functions, which combine the `mri_convert` and `readnii` functions.  Here we show that these steps are equivalent to the `readmgz` function:

```{r comp_mri, echo = TRUE, eval = TRUE, results='markup'}
img_mgz = readmgz(t1_mgz)
all(img == img_mgz)
```

Now that we have the image in R, we can plot it using the standard plotting tools for `nifti` objects:
```{r mri_plot, echo = TRUE, eval = TRUE, dependson='mri_convert'}
neurobase::ortho2(img, add.orient = FALSE, mask = img > 40)
```

Note, the image is not stored in the "RPI" format which is assumed when  displaying using the \pkg{neurobase} \code{ortho2} function.  We can use the `rpi_orient` function in fslr (version $\geq$ 2.4.0) or `fslswapdim` to reorient.

```{r reorient_show, echo = TRUE, eval = FALSE}
L = fslr::rpi_orient(img)
reoriented_img = L$img
```

```{r reorient, echo = FALSE, eval = TRUE}
L = fslr::rpi_orient(img)
reoriented_img = L$img
rm(list = "L")
```

We see that this function puts this image in the RPI format, which matches the assumed orientation for `ortho2`:

```{r mri_plot2, echo = TRUE, eval = TRUE, dependson='reorient'}
neurobase::ortho2(reoriented_img, mask = reoriented_img > 40)
```


## Brain extraction: the \code{mri\_watershed} function

The \code{mri\_watershed} function will segment the brain from the remainder of the image, such as extra-cranial tissues.  Other imaging software in R have implemented the watershed algorithm, such as \BIOpkg{EBImage} [@EBImage].  These methods have not been directly adapted for MRI nor specifically for brain extraction.  In \pkg{freesurfer}, we can pass in the \code{nifti} object and the output is a brain-extracted \code{nifti} object.

```{r watershed, echo = TRUE, eval = TRUE, dependson="mri_convert"}
ss = mri_watershed(img)
```

```{r watershed_plot_show, echo = TRUE, eval = FALSE}
ortho2(ss, mask = ss)
```
```{r watershed_plot, echo = FALSE, eval = TRUE, dependson="watershed"}
#############################
# You cannot reorient beforehand if you use the template
# in mri_watershed, which is the default
# so you reorient after
#############################
L = fslr::rpi_orient(ss)
re_ss_img = L$img
ortho2(re_ss_img, mask = re_ss_img)
mask = re_ss_img > 0
rm(list = c("L", "re_ss_img"))
```

We see that the area of the skull, eyes, face, and other areas of the image are removed.  We do see some areas that may be part of some of the membranes between the brain and the skull, but this looks like an adequate brain extraction for most analyses.

As the result in a \code{nifti} object, we can create a mask by standard logical operations.  As MRI scans are commonly non-zero, the non-zero areas of the image are the "brain":
```{r mask_show, echo = TRUE, eval = FALSE, dependson="watershed"}
mask = ss > 0
```

We can then use this mask to perform operations on the image, such as subsetting.

```{r seg_file_show, echo = TRUE, eval = FALSE}
seg_file = file = file.path(fs_subj_dir(), "bert", "mri", "aseg.mgz")
seg = readmgz(seg_file)
breaks = c(-1, fs_lut$index)
colors = rgb(fs_lut$R, fs_lut$G, fs_lut$B, 
             alpha = 0.5,
             maxColorValue = 255)
ortho2(ss, seg, col.y = colors)
```

```{r seg_file, echo = FALSE, eval = TRUE, dependson="watershed_plot"}
seg_file = file = file.path(fs_subj_dir(), 
                            "bert", "mri", "aseg.mgz")
seg = readmgz(seg_file)
L = fslr::rpi_orient(seg)
seg = L$img
breaks = c(-1, fs_lut$index)
colors = rgb(fs_lut$R, fs_lut$G, fs_lut$B,
             alpha = 0.5,
             maxColorValue = 255)
ortho2(re_ss_img, seg, col.y = colors)
rm(list = c("L", "colors", "breaks"))
```



\subsection{Bias-field correction: the \code{nu\_correct} function}

MRI images typically exhibit good contrast between soft tissue classes, but intensity inhomogeneities in the radio frequency field can cause differences in the ranges of tissue types at different spatial locations (e.g. top versus bottom of the brain).  These inhomogeneities/non-uniformities can cause problems with algorithms based on histograms, quantiles, or raw intensities \citep{zhang_segmentation_2001}.  Therefore, correction for image inhomogeneities is a crucial step in many analyses.  The Freesurfer function \code{nu\_correct} performs the non-uniformity correction by \citet{sled_nonparametric_1998} and the \pkg{freesurfer} function of the same name will run the correction and return an image.

The Freesurfer \code{nu\_correct} function requires a MNC format (\url{http://www.bic.mni.mcgill.ca/ServicesSoftware/MINC}).  For this to work, you can convert the \code{nifti} object to a MNC file using \code{nii2mnc} and pass that file into \code{nu\_correct}.  The \pkg{freesurfer} \code{nu\_correct} function will run the correction and then convert the output MNC to a NIfTI object.  

```{r nu_correct_mcn2nii, echo = TRUE, eval = TRUE,  dependson="reorient", results='markup'}
mnc = nii2mnc(reoriented_img)
print(mnc)
nu_from_mnc = nu_correct(file = mnc)
class(nu_from_mnc)
ortho2(nu_from_mnc, mask = nu_from_mnc > 40)
```

In addition to the \code{readmgz} and \code{readmgh} functions above, we have a \code{readmnc} function for reading in MINC files, after conversion to NIfTI files.  If you pass in a \code{nifti} object in directly into `nu_correct`, the function will automatically convert any NIfTI input files, and then run the correction (shown below).  We can also pass in a mask (generated from above) to run the correction only the areas of the brain.

```{r nu_correct_nifti, echo = TRUE, eval = TRUE, results='markup', dependson=c("watershed_plot", "reorient")}
nu_masked = nu_correct(file = reoriented_img, mask = mask)
class(nu_masked)
```

Overall, this correction is a way to make the intensities of the brain more homogeneous spatially.  This method is different from that implemented in FSL (and therefore \pkg{fslr}), so it provides an alternative method to the R user than currently available.


## Additional Features

For the initial release, we did not implement a method to read the annotation files and other surface-based files that Freesurfer uses.  Reading in these files are planned for a future release.  Freesurfer can also analyze diffusion tensor imaging (DTI) data and some of the functions have been adapted for \pkg{freesurfer} but have not been thoroughly tested.  


## Conclusion
The neuroimaging community has developed a large collection of tools for image processing and analysis.  These tools have additional functionality that is not present in R, such as the surface-based registration and processing of Freesurfer.  We have incorporated these tools in our previous work porting FSL to R using \pkg{fslr}.  We present a similar incorporation in the form of \pkg{freesurfer} to bridge this gap and provide R users functions from Freesurfer.  Interfacing R with existing, powerful software provides users with thoroughly-tested software and an additional community of users, which would not be available if the functions were rewritten in R.  Although this external software dependency may not be an advantage, it benefits from the years of previous testing. 

There has been an increasing popularity of similar interfacing of tools within the Python community such as Nipype \citep{gorgolewski_nipype:_2011} (https://qa.debian.org/popcon.php?package=nipype).  As many users of R may not have experience with Python or bash scripting, we believe \pkg{freesurfer} provides a lower threshold for use in the R community. 

Most importantly, as \pkg{freesurfer} is based on the R framework, all the benefits of using R are available, such as dynamic documents, Shiny applications, customized figures, and state-of-the-art statistical methods.  These benefits provide unique functionality compared to other software packages for neuroimaging.  

## Reproducibility

This paper was generated using the \CRANpkg{rticles} package [@rticles].  All necessary code to generate this report is located at: [https://github.com/muschellij2/fs_paper](https://github.com/muschellij2/fs_paper).

\bibliography{RJreferences}

# Supplemental Material

## Additional files from Freesurfer
We have created simple wrappers to read in surface, curvature, and label files from Freesurfer output.  We will show the the functions with associated output 

### Label files
Here we will read a label file for the left hemisphere cortex:

```{r read_label, eval = TRUE, results='markup'}
file = file.path(fs_subj_dir(), "bert", "label", "lh.cortex.label")
out = read_fs_label(file)
head(out)
```

The coordinates are mostly used in these files, not the value assigned.  They can be used for registration as well.  
